<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NEXUS ACCESS :: REACTOR OVERDRIVE</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body, html {
    height: 100%;
    overflow: hidden;
    background-color: #000;
    font-family: 'Courier New', Courier, monospace;
    color: #e0e0e0;
    user-select: none;
  }

  #glCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  .login-panel {
    position: fixed;
    top: 40px;
    right: 40px;
    z-index: 2;
    width: 90%;
    max-width: 400px;
    padding: 35px 25px;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid #00FFE0;
    border-radius: 6px;
    box-shadow: 0 0 15px rgba(0, 255, 224, 0.4);
    text-align: center;
    animation: panelPulse 4s ease-in-out infinite alternate;
    transition: all 0.5s ease;
  }

  @keyframes panelPulse {
    0% { box-shadow: 0 0 15px rgba(0, 255, 224, 0.4), 0 0 30px rgba(0, 100, 100, 0.1); }
    100% { box-shadow: 0 0 25px rgba(0, 255, 224, 0.7), 0 0 50px rgba(0, 150, 150, 0.3); }
  }

  .title {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 25px;
    color: #00FFE0;
    text-shadow: 0 0 8px rgba(0, 255, 224, 0.7);
    letter-spacing: 2px;
    position: relative;
    overflow: hidden;
  }
  .title::after {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 20%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(0, 255, 224, 0.4), transparent);
    animation: scanline 3s linear infinite;
  }
  @keyframes scanline {
    0% { left: -20%; }
    100% { left: 120%; }
  }

  .input-group {
    position: relative;
    margin-bottom: 20px;
    text-align: left;
  }

  .input-group label {
    display: block;
    margin-bottom: 6px;
    font-size: 14px;
    color: #aaa;
  }

  .input-group input {
    width: 100%;
    padding: 12px;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid #00887a;
    border-radius: 4px;
    color: #e0e0e0;
    font-family: inherit;
    font-size: 15px;
    outline: none;
    transition: all 0.3s ease;
  }

  .input-group input:focus {
    transform: scale(1.02);
    border-color: #00FFE0;
    box-shadow: 0 0 15px rgba(0, 255, 224, 0.8);
  }

  .btn-login-container {
      position: relative;
  }

  .btn-login {
    width: 100%;
    padding: 12px;
    background: rgba(0, 0, 0, 0.5);
    color: #00FFE0;
    border: 1px solid #00887a;
    border-radius: 4px;
    font-family: inherit;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }

  .btn-login::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0, 255, 224, 0.2), transparent);
    animation: pulse 3s infinite;
  }

  @keyframes pulse {
    0% { left: -100%; }
    100% { left: 100%; }
  }

  .btn-login:hover {
    background: rgba(0, 30, 30, 0.7);
    color: #ffffff;
    border-color: #00FFFF;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.9);
    transform: translateY(-2px);
  }

  .ripple {
    position: absolute;
    border-radius: 50%;
    background-color: rgba(0, 255, 224, 0.4);
    transform: scale(0);
    animation: ripple 0.6s linear;
  }

  @keyframes ripple {
    to {
      transform: scale(2.5);
      opacity: 0;
    }
  }

  .btn-login:active {
    transform: scale(0.98);
  }

  .loader {
    display: none;
    border: 2px solid rgba(0, 255, 224, 0.3);
    border-top: 2px solid #00FFE0;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    animation: spin 1s linear infinite;
    margin: 10px auto;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .message {
    margin-top: 15px;
    min-height: 20px;
    font-size: 14px;
    font-weight: bold;
    opacity: 0;
    transform: scale(0.9);
    transition: opacity 0.5s ease, transform 0.5s ease;
  }
  .message.show {
      opacity: 1;
      transform: scale(1);
  }

  .success {
    color: #00ffaa;
    text-shadow: 0 0 8px rgba(0, 255, 170, 0.6);
  }
  .error {
    color: #ff5555;
    text-shadow: 0 0 8px rgba(255, 85, 85, 0.6);
  }

  @media (max-width: 500px) {
    .login-panel {
      top: 20px;
      right: 20px;
      left: 20px;
      max-width: none;
      padding: 25px 20px;
    }
  }
</style>
</head>
<body>

<canvas id="glCanvas"></canvas>

<div class="login-panel">
  <h1 class="title">&gt; NEXUS REACTOR_</h1>
  <div class="input-group">
    <label for="username">USER_ID:</label>
    <input type="text" id="username" placeholder="[ENTER USERNAME]" autocomplete="off" />
  </div>
  <div class="input-group">
    <label for="password">PASS_KEY:</label>
    <input type="password" id="password" placeholder="[ENTER PASSCODE]" />
  </div>
  <div class="btn-login-container">
      <button class="btn-login" id="loginButton" onclick="handleLogin(event)">// ESTABLISH LINK //</button>
      <div class="loader" id="loader"></div>
  </div>
  <div id="message" class="message"></div>
</div>

<script>
(function() {
  'use strict';

  const canvas = document.getElementById('glCanvas');
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

  if (!gl) {
    alert('WebGL not supported! This experience requires WebGL.');
    return;
  }

  // --- 提前声明 FBO 相关变量 ---
  let sceneFBO, sceneTexture;

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    // --- 确保 FBO 存在后再重置 ---
    if (sceneFBO) {
        setupFBO(); // 当窗口大小改变时重新设置 FBO
    }
  }
  window.addEventListener('resize', resizeCanvas);


  // --- Shader Sources ---

  // --- 场景顶点着色器：计算粒子位置和生命周期 ---
  const sceneVSSource = `
    precision mediump float; // <<<--- 修复：添加精度声明以匹配片段着色器
    attribute vec2 aPosition;
    attribute vec2 aVelocity;
    attribute float aLife;
    uniform float uTime;
    uniform vec2 uResolution;
    varying float vLife;
    varying vec2 vPosition; // 传递世界坐标给片段着色器
    void main() {
        // 根据速度和时间更新位置
        vec2 pos = aPosition + aVelocity * uTime * 50.0;
        // 简单的边界包裹
        pos.x = mod(pos.x, uResolution.x * 2.0) - uResolution.x;
        pos.y = mod(pos.y, uResolution.y * 2.0) - uResolution.y;
        
        // 传递世界坐标
        vPosition = pos;

        // 转换为裁剪空间 (-1 到 1)
        vec2 clipSpace = (pos / uResolution) * 2.0 - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        // 增大点大小，随生命衰减
        gl_PointSize = 5.0 * (1.0 - aLife) + 3.0; // 基础大小+最大大小
        vLife = aLife;
    }
  `;
  // --- 场景片段着色器：定义粒子外观 ---
  const sceneFSSource = `
    precision mediump float; // 指定浮点精度
    uniform float uTime;
    varying float vLife;
    varying vec2 vPosition; // 接收世界坐标

    void main() {
        // 计算点精灵内的相对坐标 (-0.5 到 0.5)
        vec2 coord = gl_PointCoord - vec2(0.5);
        // 如果超出半径，则丢弃像素 (创造圆形点)
        if(length(coord) > 0.5) discard;
        // 计算从中心到边缘的平滑透明度
        float alpha = 1.0 - smoothstep(0.4, 0.5, length(coord));
        
        // --- 更加绚烂的颜色变化 ---
        // 基于时间和位置的色调偏移
        float hueShift = sin(uTime * 0.5 + vPosition.x * 0.01 + vPosition.y * 0.01) * 0.5 + 0.5;
        // 基于生命值的亮度变化
        float brightness = 0.8 + 0.2 * sin(vLife * 10.0 + uTime);
        
        // 使用 HSV 转 RGB 辅助函数生成颜色
        vec3 baseColor = vec3(hueShift, 1.0, brightness); // HSV (简化)
        vec3 color = mix(baseColor, vec3(0.0, 1.0, 0.878), vLife * 0.7); // 混合一点青色
        
        // 最终颜色，考虑透明度和生命值
        gl_FragColor = vec4(color, alpha * vLife * 0.9);
    }
    
    // 简化的 HSV 转 RGB (来自 Inigo Quilez)
    vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }
  `;

  // --- 后处理顶点着色器：绘制覆盖全屏的四边形 ---
  const postVSSource = `
    attribute vec2 aPosition;
    varying vec2 vUv; // 传递纹理坐标给片段着色器
    void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        // 将顶点坐标 (-1 到 1) 转换为纹理坐标 (0 到 1)
        vUv = aPosition * 0.5 + 0.5;
    }
  `;
  // --- 后处理片段着色器：应用视觉效果 ---
  const postFSSource = `
    precision mediump float; // 指定浮点精度
    uniform sampler2D uSceneTexture; // 从场景渲染得到的纹理
    uniform float uTime;
    uniform vec2 uMouse; // 鼠标位置 (0-1)
    uniform vec2 uResolution;
    uniform float uDistortionStrength; // 扭曲强度
    uniform float uBlurStrength;       // 模糊强度
    varying vec2 vUv; // 接收从顶点着色器传来的纹理坐标

    // 实现径向模糊效果的函数
    vec4 radialBlur(sampler2D tex, vec2 uv, vec2 center, float strength) {
        vec4 color = texture2D(tex, uv);
        float scale = 1.0;
        const int samples = 20; // 增加采样次数
        // 循环累加偏移坐标的颜色
        for (int i = 1; i <= 20; i++) {
            float f = float(i) / float(samples);
            // 计算指向中心的偏移向量
            vec2 offset = (center - uv) * f * strength * 0.02; // 调整缩放因子
            // 采样并累加
            color += texture2D(tex, uv + offset);
        }
        // 平均颜色值
        color /= float(samples + 1);
        return color;
    }

    void main() {
        vec2 uv = vUv;

        // --- 时间相关的全局扰动 ---
        float time = uTime * 0.5;
        uv += vec2(sin(time)*0.002, cos(time)*0.002); // 轻微漂移

        // --- 扭曲效果 ---
        // 扭曲以鼠标为中心
        vec2 distortionCenter = uMouse;
        // 计算当前像素到扭曲中心的方向和距离
        vec2 dir = uv - distortionCenter;
        float dist = length(dir);
        // 距离越近，扭曲力越强
        float power = pow(max(1.0 - dist, 0.0), 2.0) * uDistortionStrength;
        // 应用扭曲偏移
        uv += dir * power * 0.03; // 稍微加大扭曲范围

        // --- 从纹理获取基础颜色 ---
        vec4 sceneColor = texture2D(uSceneTexture, uv);

        // --- 应用径向模糊 ---
        vec4 finalColor = sceneColor;
        if (uBlurStrength > 0.0) {
             // 以屏幕中心为模糊中心
             finalColor = radialBlur(uSceneTexture, uv, vec2(0.5), uBlurStrength);
        }
        
        // --- 添加一点发光效果 ---
        float glow = dot(finalColor.rgb, vec3(0.299, 0.587, 0.114)); // 亮度
        finalColor.rgb += finalColor.rgb * glow * 0.5; // 自发光增强

        gl_FragColor = finalColor;
    }
  `;

  // --- Shader Helpers ---
  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader Compile Error (' + (type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment') + '):', gl.getShaderInfoLog(shader));
        alert('Shader compilation error. Check console for details.');
        gl.deleteShader(shader);
        return null;
    }
    return shader;
  }
  function createProgram(gl, vShader, fShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vShader);
    gl.attachShader(program, fShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program Link Error:', gl.getProgramInfoLog(program));
        alert('Shader program linking error. Check console for details.');
        return null;
    }
    return program;
  }

  // --- 编译和链接着色器程序 ---
  const sceneProgram = createProgram(gl,
      createShader(gl, gl.VERTEX_SHADER, sceneVSSource),
      createShader(gl, gl.FRAGMENT_SHADER, sceneFSSource)
  );
  if (!sceneProgram) return; // Stop if program creation failed

  const postProgram = createProgram(gl,
      createShader(gl, gl.VERTEX_SHADER, postVSSource),
      createShader(gl, gl.FRAGMENT_SHADER, postFSSource)
  );
  if (!postProgram) return; // Stop if program creation failed

  // --- 创建用于绘制全屏四边形的缓冲区 ---
  const quadVertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]); // 两个三角形
  const quadBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);

  // --- Framebuffer Object (FBO) Setup ---
  function setupFBO() {
      // 清理旧的资源 (如果存在)
      if (sceneFBO) {
          gl.deleteFramebuffer(sceneFBO);
          gl.deleteTexture(sceneTexture);
      }

      // 创建新的 FBO 对象
      sceneFBO = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, sceneFBO);

      // 创建并配置纹理，用于存储场景渲染结果
      sceneTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, sceneTexture);

      // --- 关键：使用与默认帧缓冲区兼容的格式 ---
      // 内部格式 gl.RGBA, 数据格式 gl.RGBA, 数据类型 gl.UNSIGNED_BYTE
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      // 将纹理附加到 FBO 的颜色附件 0
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, sceneTexture, 0);

      // 检查 FBO 是否完整
      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      if (status !== gl.FRAMEBUFFER_COMPLETE) {
          let errorMsg = 'Framebuffer incomplete!';
          switch(status) {
              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                  errorMsg += ' (INCOMPLETE_ATTACHMENT)';
                  break;
              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                  errorMsg += ' (INCOMPLETE_MISSING_ATTACHMENT)';
                  break;
              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                  errorMsg += ' (INCOMPLETE_DIMENSIONS)';
                  break;
              case gl.FRAMEBUFFER_UNSUPPORTED:
                  errorMsg += ' (UNSUPPORTED)';
                  break;
              default:
                  errorMsg += ' (Unknown error code: ' + status + ')';
          }
          console.error(errorMsg);
          alert(errorMsg);
      } else {
          console.log("FBO created successfully with size:", canvas.width, "x", canvas.height);
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null); // 解绑 FBO
  }


  // --- 初始化 FBO 并触发一次 resize ---
  setupFBO(); // 先创建 FBO
  resizeCanvas(); // 然后根据画布大小调整 FBO (如果需要的话)


  // --- Particle System Data ---
  const MAX_PARTICLES = 2000; // 增加最大粒子数
  let particleCount = 1000; // 初始粒子数也提高
  const positions = new Float32Array(MAX_PARTICLES * 2);
  const velocities = new Float32Array(MAX_PARTICLES * 2);
  const lifetimes = new Float32Array(MAX_PARTICLES);

  // 初始化粒子数据
  function resetParticles() {
      for (let i = 0; i < MAX_PARTICLES; i++) {
          const idx = i * 2;
          // 随机初始位置
          positions[idx]     = Math.random() * canvas.width;
          positions[idx + 1] = Math.random() * canvas.height;
          // 随机初始速度 (稍微加快一点)
          velocities[idx]     = (Math.random() - 0.5) * 3;
          velocities[idx + 1] = (Math.random() - 0.5) * 3;
          // 随机初始生命值
          lifetimes[i] = Math.random();
      }
  }
  resetParticles();

  // 创建并填充粒子属性缓冲区
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW); // 位置会动态更新

  const velocityBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, velocities, gl.STATIC_DRAW); // 速度固定

  const lifeBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, lifeBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, lifetimes, gl.DYNAMIC_DRAW); // 生命值会动态更新

  // 获取场景着色器中的 attribute 和 uniform 位置
  const scenePosLoc = gl.getAttribLocation(sceneProgram, "aPosition");
  const sceneVelLoc = gl.getAttribLocation(sceneProgram, "aVelocity");
  const sceneLifeLoc = gl.getAttribLocation(sceneProgram, "aLife");
  const sceneTimeLoc = gl.getUniformLocation(sceneProgram, "uTime");
  const sceneResLoc = gl.getUniformLocation(sceneProgram, "uResolution");

  // 获取后处理着色器中的 attribute 和 uniform 位置
  const postPosLoc = gl.getAttribLocation(postProgram, "aPosition");
  const postSceneTexLoc = gl.getUniformLocation(postProgram, "uSceneTexture");
  const postTimeLoc = gl.getUniformLocation(postProgram, "uTime");
  const postMouseLoc = gl.getUniformLocation(postProgram, "uMouse");
  const postResLoc = gl.getUniformLocation(postProgram, "uResolution");
  const postDistStrengthLoc = gl.getUniformLocation(postProgram, "uDistortionStrength");
  const postBlurStrengthLoc = gl.getUniformLocation(postProgram, "uBlurStrength");

  // 启用混合，实现透明效果
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // 改为 ONE，实现发光叠加效果
  // 设置清除颜色为黑色
  gl.clearColor(0.0, 0.0, 0.0, 1.0);

  // --- Mouse Interaction ---
  let mouseX = 0.5, mouseY = 0.5;
  canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX / canvas.width;
      mouseY = 1.0 - (e.clientY / canvas.height); // WebGL Y轴向上
  });
  canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      mouseX = touch.clientX / canvas.width;
      mouseY = 1.0 - (touch.clientY / canvas.height);
  }, { passive: false });

  // --- Effect Controls ---
  let distortionStrength = 0.0;
  let blurStrength = 0.0;
  let globalTime = 0;

  // 触发扭曲效果
  function triggerDistortion() {
      distortionStrength = 1.5; // 稍微增强
  }
  // 触发模糊效果
  function triggerBlur() {
      blurStrength = 1.0; // 稍微增强
  }

  // --- Render Loop ---
  function render(currentTimeMs) {
    globalTime = currentTimeMs / 1000.0;

    // --- 更新粒子数据 ---
    for(let i = 0; i < particleCount; i++) {
        lifetimes[i] -= 0.008; // 稍微减慢生命消耗速度
        if (lifetimes[i] <= 0.0) { // 如果生命耗尽
            const idx = i * 2;
            // 重置位置
            positions[idx] = Math.random() * canvas.width;
            positions[idx + 1] = Math.random() * canvas.height;
            // 重置生命
            lifetimes[i] = 1.0;
        }
    }
    // 将更新后的数据上传到 GPU 缓冲区
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, positions);
    gl.bindBuffer(gl.ARRAY_BUFFER, lifeBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, lifetimes);

    // --- Scene Pass (渲染场景到 FBO) ---
    gl.bindFramebuffer(gl.FRAMEBUFFER, sceneFBO); // 绑定到 FBO
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 清除 FBO 颜色缓冲区

    gl.useProgram(sceneProgram);
    // 传递 uniforms
    gl.uniform1f(sceneTimeLoc, globalTime);
    gl.uniform2f(sceneResLoc, canvas.width, canvas.height);

    // 设置 attributes
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(scenePosLoc);
    gl.vertexAttribPointer(scenePosLoc, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
    gl.enableVertexAttribArray(sceneVelLoc);
    gl.vertexAttribPointer(sceneVelLoc, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, lifeBuffer);
    gl.enableVertexAttribArray(sceneLifeLoc);
    gl.vertexAttribPointer(sceneLifeLoc, 1, gl.FLOAT, false, 0, 0);

    // 绘制粒子
    gl.drawArrays(gl.POINTS, 0, particleCount);

    // --- Post-Process Pass (将 FBO 内容渲染到屏幕) ---
    gl.bindFramebuffer(gl.FRAMEBUFFER, null); // 绑定回默认帧缓冲 (屏幕)
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 清除屏幕缓冲区

    gl.useProgram(postProgram);
    // 传递 uniforms
    gl.uniform1i(postSceneTexLoc, 0); // 纹理单元 0
    gl.uniform1f(postTimeLoc, globalTime);
    gl.uniform2f(postMouseLoc, mouseX, mouseY);
    gl.uniform2f(postResLoc, canvas.width, canvas.height);
    gl.uniform1f(postDistStrengthLoc, distortionStrength);
    gl.uniform1f(postBlurStrengthLoc, blurStrength);

    // 绑定 FBO 纹理到纹理单元 0
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, sceneTexture);

    // 设置 attributes (用于绘制全屏四边形)
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    gl.enableVertexAttribArray(postPosLoc);
    gl.vertexAttribPointer(postPosLoc, 2, gl.FLOAT, false, 0, 0);

    // 绘制全屏四边形
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // 效果强度随时间衰减
    distortionStrength *= 0.92; // 稍微加快衰减
    blurStrength *= 0.90; // 稍微加快衰减

    requestAnimationFrame(render); // 请求下一帧
  }
  requestAnimationFrame(render); // 启动渲染循环

  // ========== UI Logic ==========
  function showLoader(show) {
      const loader = document.getElementById('loader');
      const button = document.getElementById('loginButton');
      if (show) {
          loader.style.display = 'block';
          button.disabled = true;
          button.textContent = '// AUTHENTICATING //';
      } else {
          loader.style.display = 'none';
          button.disabled = false;
          button.textContent = '// ESTABLISH LINK //';
      }
  }

  function showMessage(text, isSuccess) {
      const msg = document.getElementById('message');
      msg.classList.remove('show');
      msg.className = 'message';
      setTimeout(() => {
          msg.className = 'message ' + (isSuccess ? 'success' : 'error') + ' show';
          msg.textContent = text;
      }, 10);
  }

  function createRipple(event) {
    const button = event.currentTarget;
    const circle = document.createElement("span");
    const diameter = Math.max(button.clientWidth, button.clientHeight);
    const radius = diameter / 2;
    circle.style.width = circle.style.height = `${diameter}px`;
    circle.style.left = `${event.clientX - button.getBoundingClientRect().left - radius}px`;
    circle.style.top = `${event.clientY - button.getBoundingClientRect().top - radius}px`;
    circle.classList.add("ripple");
    const ripple = button.getElementsByClassName("ripple")[0];
    if (ripple) {
      ripple.remove();
    }
    button.appendChild(circle);
  }

  document.getElementById('loginButton').addEventListener('click', function(e) {
      createRipple(e);
      triggerDistortion();
  });

  async function handleLogin(event) {
    const u = document.getElementById('username').value.trim();
    const p = document.getElementById('password').value.trim();

    if (!u || !p) {
      showMessage('[ERROR] CREDENTIALS_REQUIRED', false);
      triggerDistortion();
      return;
    }

    showLoader(true);
    showMessage('', false);

    await new Promise(resolve => setTimeout(resolve, 2000));

    if (u === 'admin' && p === 'overdrive') {
      showMessage('[SUCCESS] REACTOR_STABLE // WELCOME, COMMANDER.', true);
      blurStrength = 2.0; // 这现在有效了，且更强
      distortionStrength = 3.0;
      particleCount = Math.min(particleCount + 500, MAX_PARTICLES); // 增加更多粒子
    } else {
      showMessage('[FAILURE] ACCESS_DENIED // REACTOR_INSTABILITY', false);
      distortionStrength = 4.0; // 增强失败时的扭曲
      triggerDistortion();
    }

    showLoader(false);
  }

  document.addEventListener('keypress', e => {
    if (e.key === 'Enter') handleLogin();
  });

})();
</script>

</body>
</html>  