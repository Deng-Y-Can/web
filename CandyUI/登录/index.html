<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Background</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            height: 100%;
            overflow: hidden;
            background-color: #0d0d1a; /* Slightly adjusted dark blue background */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Container for the WebGL canvas --- */
        #webgl-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Behind the login card */
        }

        /* --- The login card --- */
        .login-card {
            position: relative;
            z-index: 2; /* Above the WebGL background */
            width: 90%;
            max-width: 400px;
            padding: 40px 30px;
            background-color: rgba(20, 20, 35, 0.88); /* Darker, semi-transparent card */
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5), 0 5px 15px rgba(0, 0, 0, 0.3), inset 0 0 15px rgba(100, 150, 255, 0.1); /* Subtle inner glow */
            text-align: left;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid rgba(100, 150, 255, 0.15); /* Neon blue border */
        }

            .login-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 20px 45px rgba(0, 0, 0, 0.6), 0 10px 20px rgba(0, 0, 0, 0.4), inset 0 0 20px rgba(100, 150, 255, 0.2);
            }

        .card-header {
            text-align: center;
            margin-bottom: 30px;
            color: #f8f8ff; /* Slightly cooler white */
            font-size: 26px;
            font-weight: 500;
            letter-spacing: -0.5px;
            text-shadow: 0 0 8px rgba(100, 150, 255, 0.5); /* Header glow */
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-label {
            display: block;
            margin-bottom: 8px;
            color: #bbb; /* Slightly lighter label */
            font-size: 14px;
            font-weight: 500;
        }

        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 14px 15px;
            border: 1px solid #3a3a5a; /* Darker, bluish border */
            border-radius: 8px;
            font-family: inherit;
            font-size: 16px;
            color: #e0e0e0;
            background-color: rgba(30, 30, 50, 0.75); /* Darker input bg */
            transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
        }

            input[type="text"]:focus, input[type="password"]:focus {
                outline: none;
                border-color: #6496ff; /* Brighter neon blue focus */
                box-shadow: 0 0 0 3px rgba(100, 150, 255, 0.3), inset 0 0 5px rgba(100, 150, 255, 0.2);
                background-color: rgba(40, 40, 60, 0.85);
            }

            input[type="text"]::placeholder, input[type="password"]::placeholder {
                color: #888;
            }

        .btn-submit {
            width: 100%;
            padding: 15px;
            margin-top: 10px;
            background: linear-gradient(135deg, #6496ff, #bd4dff); /* Neon blue to purple gradient */
            color: #ffffff;
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 10px rgba(100, 150, 255, 0.3); /* Button shadow */
        }

            .btn-submit:hover {
                background: linear-gradient(135deg, #5a8be6, #aa45e6); /* Slightly darker on hover */
                box-shadow: 0 6px 15px rgba(100, 150, 255, 0.4), 0 0 15px rgba(100, 150, 255, 0.2);
            }

            .btn-submit:active {
                transform: scale(0.98);
            }

            .btn-submit:disabled {
                background: #555;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }

        .loader {
            display: none;
            width: 20px;
            height: 20px;
            margin: 20px auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-top: 2px solid #ffffff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .message {
            margin-top: 25px;
            min-height: 24px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease, transform 0.4s ease, color 0.4s ease;
            text-align: center;
        }

            .message.show {
                opacity: 1;
                transform: translateY(0);
            }

        .success {
            color: #4ade80; /* Green */
            text-shadow: 0 0 8px rgba(74, 222, 128, 0.5); /* Success glow */
        }

        .error {
            color: #f87171; /* Red */
            text-shadow: 0 0 8px rgba(248, 113, 113, 0.5); /* Error glow */
        }

        /* --- Shimmer animation on input focus --- */
        @keyframes inputFocusIn {
            from {
                background-position: 100% 0;
            }

            to {
                background-position: 0 0;
            }
        }

        input[type="text"]:focus, input[type="password"]:focus {
            background-image: linear-gradient(90deg, transparent 50%, rgba(100, 150, 255, 0.1) 50%);
            background-size: 200% 100%;
            animation: inputFocusIn 0.6s ease;
        }

        /* --- Error Message Display --- */
        #webgl-error {
            display: none;
            color: #f87171;
            font-size: 18px;
            text-align: center;
            margin: auto;
            padding: 20px;
            font-family: sans-serif;
            z-index: 10;
            position: relative;
            background-color: rgba(20, 20, 35, 0.95);
            border: 1px solid #555;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <!-- Canvas for WebGL rendering -->
    <div id="webgl-bg"></div>
    <!-- Error message placeholder -->
    <div id="webgl-error">WebGL initialization failed. Please check console for details or try a different browser.</div>

    <!-- Login Form Card -->
    <div class="login-card">
        <h1 class="card-header">Secure Access</h1>
        <form id="loginForm">
            <div class="input-group">
                <label for="username" class="input-label">Username</label>
                <input type="text" id="username" name="username" placeholder="Enter your username" autocomplete="off" required />
            </div>
            <div class="input-group">
                <label for="password" class="input-label">Password</label>
                <input type="password" id="password" name="password" placeholder="Enter your password" required />
            </div>
            <button type="submit" class="btn-submit">Sign In</button>
            <div class="loader" id="loader"></div>
            <div id="message" class="message"></div>
        </form>
    </div>

    <script>
        (function () {
            'use strict';

            // --- 1. WebGL Setup ---
            const webglContainer = document.getElementById('webgl-bg');
            const errorDiv = document.getElementById('webgl-error');
            const canvas = document.createElement('canvas');
            webglContainer.appendChild(canvas);

            // Try to get a WebGL context with better options
            let gl = canvas.getContext('webgl', { antialias: true, alpha: false }) ||
                canvas.getContext('experimental-webgl', { antialias: true, alpha: false });

            if (!gl) {
                console.error("WebGL not supported");
                webglContainer.style.display = 'none';
                errorDiv.style.display = 'block';
                return;
            }

            // --- Basic WebGL state setup ---
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);
            gl.frontFace(gl.CCW);
            gl.enable(gl.BLEND);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // Better blending for glow
            gl.clearColor(0.05, 0.05, 0.1, 1.0); // Adjusted dark blue background (#0d0d1a)


            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();


            // --- 2. Shader Sources ---

            // --- Vertex Shader for the Sphere ---
            const sphereVSSource = `#version 100
        precision highp float;
        attribute vec3 aPosition;
        attribute vec3 aNormal;
        uniform mat4 uMVPMatrix;
        uniform mat3 uNormalMatrix;
        varying vec3 vNormal;
        varying vec3 vViewPos;
        varying vec3 vWorldPos;
        void main() {
            vec4 worldPos = uMVPMatrix * vec4(aPosition, 1.0);
            gl_Position = worldPos;
            vNormal = normalize(uNormalMatrix * aNormal);
            vViewPos = vec3(0.0) - worldPos.xyz; // Camera at origin
            vWorldPos = worldPos.xyz;
        }
      `;

            // --- Fragment Shader for the Sphere (Enhanced Phong Lighting) ---
            const sphereFSSource = `#version 100
        precision highp float;
        varying vec3 vNormal;
        varying vec3 vViewPos;
        varying vec3 vWorldPos;
        uniform float uTime;
        uniform vec3 uBaseColor;
        uniform vec3 uLightPos; // Point light position
        void main() {
            // Light properties
            vec3 lightColor = vec3(1.0, 0.95, 0.9); // Warmer white light

            // Material properties
            vec3 objectColor = uBaseColor;
            float shininess = 96.0; // Increased shininess

            // Normals
            vec3 norm = normalize(vNormal);
            vec3 lightDir = normalize(uLightPos - vWorldPos);
            vec3 viewDir = normalize(vViewPos);
            vec3 reflectDir = reflect(-lightDir, norm);

            // Ambient
            float ambientStrength = 0.2;
            vec3 ambient = ambientStrength * lightColor;

            // Diffuse
            float diff = max(dot(norm, lightDir), 0.0);
            vec3 diffuse = diff * lightColor;

            // Specular
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
            vec3 specular = spec * lightColor;

            vec3 result = (ambient + diffuse + specular) * objectColor;

            // Fresnel effect for stronger edge glow
            float fresnel = pow(1.0 - max(dot(viewDir, norm), 0.0), 2.0); // Reduced power for subtlety
            vec3 glowColor = mix(objectColor, vec3(1.0), 0.7); // Glow towards bright white
            result += fresnel * 0.8 * glowColor; // Increased intensity

            // Pulsating opacity based on color/brightness and time
            float brightness = dot(result, vec3(0.299, 0.587, 0.114)); // Luminance
            float pulse = sin(uTime * 3.0 + brightness * 15.0) * 0.15 + 0.85; // Faster, smaller range
            float alpha = 0.35 + brightness * 0.3; // More opaque where brighter
            alpha *= pulse;

            gl_FragColor = vec4(result, alpha);
        }
      `;

            // --- Vertex Shader for Particles ---
            const particleVSSource = `#version 100
        precision highp float;
        attribute vec3 aPosition;
        uniform mat4 uMVPMatrix;
        uniform float uPointSize;
        void main() {
            gl_Position = uMVPMatrix * vec4(aPosition, 1.0);
            gl_PointSize = uPointSize;
        }
      `;

            // --- Fragment Shader for Particles ---
            const particleFSSource = `#version 100
        precision highp float;
        uniform float uTime;
        uniform vec3 uParticleColorStart;
        uniform vec3 uParticleColorEnd;
        void main() {
            // Make particles circular
            vec2 coord = gl_PointCoord - vec2(0.5);
            if(length(coord) > 0.5) discard;

            // Color gradient based on distance from center
            float dist = length(coord);
            vec3 color = mix(uParticleColorStart, uParticleColorEnd, dist);

            // Subtle pulsing and fading at edges
            float pulse = sin(uTime * 6.0 + gl_PointCoord.x * 15.0) * 0.1 + 0.9;
            float alpha = 1.0 - smoothstep(0.3, 0.5, dist); // Fade out at edges
            alpha *= pulse * 0.6; // Overall lower alpha for subtlety

            gl_FragColor = vec4(color, alpha);
        }
      `;


            // --- 3. Shader Compilation and Linking Helper Functions ---
            function compileShader(source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const log = gl.getShaderInfoLog(shader);
                    console.error(`Shader Compile Error (${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'}):`, log);
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createAndLinkProgram(vertexShaderSource, fragmentShaderSource) {
                const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

                if (!vertexShader || !fragmentShader) {
                    console.error("Failed to compile shaders.");
                    return null;
                }

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    const log = gl.getProgramInfoLog(program);
                    console.error('Program Link Error:', log);
                    gl.deleteProgram(program);
                    return null;
                }

                gl.detachShader(program, vertexShader);
                gl.detachShader(program, fragmentShader);
                gl.deleteShader(vertexShader);
                gl.deleteShader(fragmentShader);

                return program;
            }

            // --- 4. Create and Link Shader Programs ---
            const sphereProgram = createAndLinkProgram(sphereVSSource, sphereFSSource);
            const particleProgram = createAndLinkProgram(particleVSSource, particleFSSource);
            if (!sphereProgram || !particleProgram) {
                console.error('Failed to initialize one or more shader programs.');
                webglContainer.style.display = 'none';
                errorDiv.style.display = 'block';
                return;
            }

            // --- 5. Get Attribute and Uniform Locations ---
            const sphereAttribLocs = {
                position: gl.getAttribLocation(sphereProgram, 'aPosition'),
                normal: gl.getAttribLocation(sphereProgram, 'aNormal')
            };
            const sphereUniformLocs = {
                mvpMatrix: gl.getUniformLocation(sphereProgram, 'uMVPMatrix'),
                normalMatrix: gl.getUniformLocation(sphereProgram, 'uNormalMatrix'),
                time: gl.getUniformLocation(sphereProgram, 'uTime'),
                baseColor: gl.getUniformLocation(sphereProgram, 'uBaseColor'),
                lightPos: gl.getUniformLocation(sphereProgram, 'uLightPos')
            };

            const particleAttribLocs = {
                position: gl.getAttribLocation(particleProgram, 'aPosition')
            };
            const particleUniformLocs = {
                mvpMatrix: gl.getUniformLocation(particleProgram, 'uMVPMatrix'),
                pointSize: gl.getUniformLocation(particleProgram, 'uPointSize'),
                time: gl.getUniformLocation(particleProgram, 'uTime'),
                particleColorStart: gl.getUniformLocation(particleProgram, 'uParticleColorStart'),
                particleColorEnd: gl.getUniformLocation(particleProgram, 'uParticleColorEnd')
            };


            // --- 6. Generate Sphere Geometry ---
            function createSphere(radius, widthSegments, heightSegments) {
                const vertices = [];
                const normals = [];
                const indices = [];

                widthSegments = Math.max(3, Math.floor(widthSegments));
                heightSegments = Math.max(2, Math.floor(heightSegments));

                const phiStart = 0;
                const phiLength = Math.PI * 2;
                const thetaStart = 0;
                const thetaLength = Math.PI;

                for (let y = 0; y <= heightSegments; y++) {
                    const v = y / heightSegments;
                    const theta = thetaStart + v * thetaLength;

                    for (let x = 0; x <= widthSegments; x++) {
                        const u = x / widthSegments;
                        const phi = phiStart + u * phiLength;

                        const px = - radius * Math.cos(phi) * Math.sin(theta);
                        const py = radius * Math.cos(theta);
                        const pz = radius * Math.sin(phi) * Math.sin(theta);

                        vertices.push(px, py, pz);
                        normals.push(px / radius, py / radius, pz / radius);
                    }
                }

                for (let y = 0; y < heightSegments; y++) {
                    const rowStart = y * (widthSegments + 1);
                    const nextRowStart = (y + 1) * (widthSegments + 1);

                    for (let x = 0; x < widthSegments; x++) {
                        const a = rowStart + x;
                        const b = nextRowStart + x;
                        const c = nextRowStart + x + 1;
                        const d = rowStart + x + 1;

                        if (y !== 0) {
                            indices.push(a, b, d);
                        }
                        if (y !== heightSegments - 1) {
                            indices.push(b, c, d);
                        }
                    }
                }

                return {
                    position: new Float32Array(vertices),
                    normal: new Float32Array(normals),
                    index: new Uint16Array(indices)
                };
            }

            // --- 7. Create Particle System ---
            function createParticleSystem(numParticles) {
                const positions = new Float32Array(numParticles * 3);
                // Initialize particles in a larger volume
                for (let i = 0; i < numParticles * 3; i++) {
                    positions[i] = (Math.random() - 0.5) * 200.0; // Spread them out more
                }
                return positions;
            }

            // --- 8. Create Buffers ---
            const sphereGeometry = createSphere(1.0, 32, 16); // Base unit sphere
            const spherePositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, spherePositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphereGeometry.position, gl.STATIC_DRAW);

            const sphereNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphereGeometry.normal, gl.STATIC_DRAW);

            const sphereIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphereGeometry.index, gl.STATIC_DRAW);
            const numSphereIndices = sphereGeometry.index.length;

            const numParticles = 1500; // Increase particle count
            let particlePositions = createParticleSystem(numParticles); // Store in JS memory
            const particleBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, particlePositions, gl.DYNAMIC_DRAW); // Initially upload data


            // --- 9. Sphere Instances Data (Updated Colors & Dynamics) ---
            const spheres = [
                { position: [0, 0, -5], scale: 1.5, baseRotationSpeed: 0.5, oscSpeed: 0.7, oscAmp: 0.3, color: [0.4, 0.7, 1.0] }, // Brighter Blue
                { position: [-4, 2, -8], scale: 1.0, baseRotationSpeed: -0.6, oscSpeed: 0.5, oscAmp: 0.4, color: [1.0, 0.4, 0.8] }, // Magenta
                { position: [5, -1, -12], scale: 0.8, baseRotationSpeed: 0.8, oscSpeed: 0.9, oscAmp: 0.2, color: [0.3, 0.9, 0.9] }, // Cyan
                { position: [2, 3, -6], scale: 1.2, baseRotationSpeed: -0.3, oscSpeed: 0.4, oscAmp: 0.5, color: [0.9, 0.6, 0.2] }, // Amber/Orange
                { position: [-3, -2, -10], scale: 0.9, baseRotationSpeed: 0.4, oscSpeed: 0.6, oscAmp: 0.35, color: [0.6, 0.4, 1.0] } // Purple
            ];
            const modelMatrices = spheres.map(() => new Float32Array(16)); // Pre-allocate matrices


            // --- 10. Matrix Utilities (Same as before) ---
            function mat4_identity(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            }

            function mat4_perspective(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[15] = 0;
                if (far != null && far !== Infinity) {
                    const nf = 1 / (near - far);
                    out[10] = (far + near) * nf;
                    out[14] = (2 * far * near) * nf;
                } else {
                    out[10] = -1;
                    out[14] = -2 * near;
                }
                return out;
            }

            function mat4_translate(out, a, v) {
                const x = v[0], y = v[1], z = v[2];
                let a00, a01, a02, a03;
                let a10, a11, a12, a13;
                let a20, a21, a22, a23;

                if (a === out) {
                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                } else {
                    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

                    out[12] = a00 * x + a10 * y + a20 * z + a[12];
                    out[13] = a01 * x + a11 * y + a21 * z + a[13];
                    out[14] = a02 * x + a12 * y + a22 * z + a[14];
                    out[15] = a03 * x + a13 * y + a23 * z + a[15];
                }
                return out;
            }

            function mat4_scale(out, a, v) {
                const x = v[0], y = v[1], z = v[2];
                out[0] = a[0] * x; out[1] = a[1] * x; out[2] = a[2] * x; out[3] = a[3] * x;
                out[4] = a[4] * y; out[5] = a[5] * y; out[6] = a[6] * y; out[7] = a[7] * y;
                out[8] = a[8] * z; out[9] = a[9] * z; out[10] = a[10] * z; out[11] = a[11] * z;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            }

            function mat4_rotateY(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0];
                const a01 = a[1];
                const a02 = a[2];
                const a03 = a[3];
                const a10 = a[4];
                const a11 = a[5];
                const a12 = a[6];
                const a13 = a[7];

                if (a !== out) {
                    out[8] = a[8];
                    out[9] = a[9];
                    out[10] = a[10];
                    out[11] = a[11];
                    out[12] = a[12];
                    out[13] = a[13];
                    out[14] = a[14];
                    out[15] = a[15];
                }

                out[0] = a00 * c - a10 * s;
                out[1] = a01 * c - a11 * s;
                out[2] = a02 * c - a12 * s;
                out[3] = a03 * c - a13 * s;
                out[4] = a00 * s + a10 * c;
                out[5] = a01 * s + a11 * c;
                out[6] = a02 * s + a12 * c;
                out[7] = a03 * s + a13 * c;
                return out;
            }

            // --- New Rotation Function for X axis ---
            function mat4_rotateX(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a[4];
                const a11 = a[5];
                const a12 = a[6];
                const a13 = a[7];
                const a20 = a[8];
                const a21 = a[9];
                const a22 = a[10];
                const a23 = a[11];

                if (a !== out) {
                    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }

                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                out[8] = a10 * -s + a20 * c;
                out[9] = a11 * -s + a21 * c;
                out[10] = a12 * -s + a22 * c;
                out[11] = a13 * -s + a23 * c;
                return out;
            }

            function mat4_multiply(out, a, b) {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return out;
            }

            function mat3_fromMat4(out, m) {
                out[0] = m[0]; out[1] = m[1]; out[2] = m[2];
                out[3] = m[4]; out[4] = m[5]; out[5] = m[6];
                out[6] = m[8]; out[7] = m[9]; out[8] = m[10];
                return out;
            }

            function mat3_transpose(out, a) {
                const a01 = a[1], a02 = a[2];
                const a12 = a[5];
                out[1] = a[3];
                out[2] = a[6];
                out[3] = a01;
                out[5] = a[7];
                out[6] = a02;
                out[7] = a12;
                return out;
            }

            function mat3_invert(out, a) {
                const a00 = a[0], a01 = a[1], a02 = a[2];
                const a10 = a[3], a11 = a[4], a12 = a[5];
                const a20 = a[6], a21 = a[7], a22 = a[8];

                const b01 = a22 * a11 - a12 * a21;
                const b11 = -a22 * a10 + a12 * a20;
                const b21 = a21 * a10 - a11 * a20;

                let det = a00 * b01 + a01 * b11 + a02 * b21;
                if (!det) { return null; }
                det = 1.0 / det;

                out[0] = b01 * det;
                out[1] = (-a22 * a01 + a02 * a21) * det;
                out[2] = (a12 * a01 - a02 * a11) * det;
                out[3] = b11 * det;
                out[4] = (a22 * a00 - a02 * a20) * det;
                out[5] = (-a12 * a00 + a02 * a10) * det;
                out[6] = b21 * det;
                out[7] = (-a21 * a00 + a01 * a20) * det;
                out[8] = (a11 * a00 - a01 * a10) * det;

                return out;
            }

            function mat3_normalFromMat4(out, modelViewMatrix) {
                mat3_fromMat4(out, modelViewMatrix);
                const inverted = mat3_invert([], out);
                if (!inverted) { return null; }
                mat3_transpose(out, inverted);
                return out;
            }


            // --- 11. Animation Variables ---
            let globalTime = 0;
            const viewMatrix = mat4_identity(new Float32Array(16));
            const projectionMatrix = new Float32Array(16);
            const mvpMatrix = new Float32Array(16);
            const normalMatrix = new Float32Array(9);
            const lightPosition = new Float32Array([3.0, 5.0, 0.0]); // Fixed light position in world space

            // --- 12. Update Particle Positions (Enhanced Flow) ---
            function updateParticles(deltaTime) {
                // Move particles primarily along the Z-axis (into/out of screen)
                const flowSpeed = 15.0; // Speed of the main flow
                const driftSpeed = 2.0;  // Speed of random drift
                const riseSpeed = 1.0;   // Speed of upward drift

                for (let i = 0; i < particlePositions.length; i += 3) {
                    // Main directional flow (Z-axis)
                    particlePositions[i + 2] += flowSpeed * deltaTime;

                    // Random drift in X and Y
                    particlePositions[i] += (Math.random() - 0.5) * driftSpeed * deltaTime;
                    particlePositions[i + 1] += (Math.random() - 0.5) * driftSpeed * deltaTime;

                    // Gentle upward drift (Y-axis)
                    particlePositions[i + 1] += riseSpeed * deltaTime;

                    // Wrap around if they go too far
                    // Check Z (depth) first, as it's the main flow direction
                    if (particlePositions[i + 2] > 100) { // Reset when too far forward
                        particlePositions[i + 2] = -100;
                        // Also randomize X and Y on reset for variety
                        particlePositions[i] = (Math.random() - 0.5) * 200.0;
                        particlePositions[i + 1] = (Math.random() - 0.5) * 200.0;
                    }
                    // Optional: Wrap X/Y if they drift too far sideways/up-down
                    // This creates a tunnel-like effect.
                    /*
                    if(Math.abs(particlePositions[i]) > 100) particlePositions[i] = -Math.sign(particlePositions[i]) * 100;
                    if(Math.abs(particlePositions[i+1]) > 100) particlePositions[i+1] = -Math.sign(particlePositions[i+1]) * 100;
                    */
                }

                // Re-upload the entire updated array to the GPU buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, particlePositions, gl.DYNAMIC_DRAW);
            }


            // --- 13. Render Loop ---
            let lastTime = 0;
            function render(currentTimeMs) {
                const currentTime = currentTimeMs / 1000.0;
                const deltaTime = currentTime - globalTime;
                globalTime = currentTime;

                resizeCanvas();

                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                const aspectRatio = canvas.width / canvas.height;
                mat4_perspective(projectionMatrix, Math.PI / 3, aspectRatio, 0.1, 1000.0); // Increased far plane

                // --- Draw Particles First (Background Layer) ---
                gl.useProgram(particleProgram);
                gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
                gl.enableVertexAttribArray(particleAttribLocs.position);
                gl.vertexAttribPointer(particleAttribLocs.position, 3, gl.FLOAT, false, 0, 0);

                // Update particle positions (using the enhanced method)
                updateParticles(deltaTime);

                const particleMVP = mat4_multiply([], projectionMatrix, viewMatrix); // Particles use identity model matrix
                gl.uniformMatrix4fv(particleUniformLocs.mvpMatrix, false, particleMVP);
                gl.uniform1f(particleUniformLocs.time, globalTime);
                gl.uniform1f(particleUniformLocs.pointSize, 3.0); // Slightly larger points
                // Use gradient colors for particles
                gl.uniform3f(particleUniformLocs.particleColorStart, 0.6, 0.8, 1.0); // Light blue core
                gl.uniform3f(particleUniformLocs.particleColorEnd, 0.9, 0.6, 1.0);   // Lavender/Magenta edge


                gl.drawArrays(gl.POINTS, 0, numParticles);


                // --- Draw Spheres ---
                gl.useProgram(sphereProgram);
                gl.bindBuffer(gl.ARRAY_BUFFER, spherePositionBuffer);
                gl.enableVertexAttribArray(sphereAttribLocs.position);
                gl.vertexAttribPointer(sphereAttribLocs.position, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
                gl.enableVertexAttribArray(sphereAttribLocs.normal);
                gl.vertexAttribPointer(sphereAttribLocs.normal, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);

                gl.uniform1f(sphereUniformLocs.time, globalTime);
                gl.uniform3fv(sphereUniformLocs.lightPos, lightPosition); // Set light position once

                // Iterate through each sphere instance
                for (let i = 0; i < spheres.length; i++) {
                    const sphere = spheres[i];

                    // Build Model Matrix for this sphere with enhanced dynamics
                    let modelMatrix = modelMatrices[i];
                    mat4_identity(modelMatrix);

                    // 1. Translate to base position
                    mat4_translate(modelMatrix, modelMatrix, sphere.position);

                    // 2. Apply oscillating translation for subtle movement
                    const oscOffsetX = Math.sin(globalTime * sphere.oscSpeed) * sphere.oscAmp;
                    const oscOffsetY = Math.cos(globalTime * sphere.oscSpeed * 0.7) * sphere.oscAmp * 0.7; // Different freq/amp for Y
                    mat4_translate(modelMatrix, modelMatrix, [oscOffsetX, oscOffsetY, 0]);

                    // 3. Scale
                    mat4_scale(modelMatrix, modelMatrix, [sphere.scale, sphere.scale, sphere.scale]);

                    // 4. Apply combined rotations
                    // Base Y rotation + Oscillating X rotation for wobble
                    const totalYRot = globalTime * sphere.baseRotationSpeed;
                    const oscXRot = Math.sin(globalTime * sphere.oscSpeed * 1.2) * sphere.oscAmp * 0.5; // Wobble on X axis
                    mat4_rotateY(modelMatrix, modelMatrix, totalYRot);
                    mat4_rotateX(modelMatrix, modelMatrix, oscXRot); // Apply X rotation after Y


                    // Calculate MVP and Normal Matrices
                    mat4_multiply(mvpMatrix, projectionMatrix, mat4_multiply([], viewMatrix, modelMatrix));
                    mat3_normalFromMat4(normalMatrix, mat4_multiply([], viewMatrix, modelMatrix)); // Include view for normal calc if view wasn't identity

                    // Set uniforms for this sphere
                    gl.uniformMatrix4fv(sphereUniformLocs.mvpMatrix, false, mvpMatrix);
                    gl.uniformMatrix3fv(sphereUniformLocs.normalMatrix, false, normalMatrix);
                    gl.uniform3fv(sphereUniformLocs.baseColor, sphere.color); // Set unique color

                    // Draw!
                    gl.drawElements(gl.TRIANGLES, numSphereIndices, gl.UNSIGNED_SHORT, 0);
                }

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);


            // ========== 14. UI Logic (Unchanged) ==========
            const form = document.getElementById('loginForm');
            const loader = document.getElementById('loader');
            const messageEl = document.getElementById('message');

            function showMessage(text, isSuccess) {
                messageEl.classList.remove('show');
                messageEl.className = 'message';
                setTimeout(() => {
                    messageEl.className = 'message ' + (isSuccess ? 'success' : 'error') + ' show';
                    messageEl.textContent = text;
                }, 10);
            }

            form.addEventListener('submit', async function (e) {
                e.preventDefault();
                const formData = new FormData(form);
                const u = formData.get('username').trim();
                const p = formData.get('password').trim();

                if (!u || !p) {
                    showMessage('Please fill in both fields.', false);
                    return;
                }

                loader.style.display = 'block';
                form.querySelector('.btn-submit').disabled = true;
                showMessage('', false);

                await new Promise(resolve => setTimeout(resolve, 2000));

                if (u === 'admin' && p === 'sphere') {
                    showMessage('Login successful. Welcome!', true);
                } else {
                    showMessage('Invalid username or password.', false);
                }

                loader.style.display = 'none';
                form.querySelector('.btn-submit').disabled = false;
            });

            window.addEventListener('load', () => {
                document.getElementById('username').focus();
            });

        })();
    </script>

</body>
</html>  